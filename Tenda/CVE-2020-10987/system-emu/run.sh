#!/bin/bash

# 启动 ssh 服务
/etc/init.d/ssh start

# --- 修改1: 自动获取容器自身的IP地址 ---
# 容器通过macvlan从DHCP获取IP后，我们在这里捕获它
CONTAINER_IP=$(hostname -I | awk '{print $1}')
echo "本容器IP地址 (Container IP): $CONTAINER_IP"

# 配置网卡 (这部分假设主机的br0已存在并正确配置)
tunctl -t tap0
ifconfig tap0 0.0.0.0 promisc up
brctl addif br0 tap0

# 启动 http 服务 (用于文件传输)
nohup python3 -m http.server 8000 1>&/dev/null &

# 进入 qemu 镜像目录
cd /root/images

/usr/bin/expect<<EOF
set timeout 10000
spawn qemu-system-arm -M vexpress-a9 -kernel vmlinuz-3.2.0-4-vexpress -initrd initrd.img-3.2.0-4-vexpress -drive if=sd,file=debian_wheezy_armhf_standard.qcow2 -append "root=/dev/mmcblk0p2" -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic

expect "debian-armhf login:"
send "root\r"
expect "Password:"
send "root\r"

# --- 修改2: 让QEMU虚拟机使用DHCP获取IP ---
expect "root@debian-armhf:~# "
send "dhclient eth0\r"

# 等待DHCP分配IP，可以适当增加等待时间
expect "root@debian-armhf:~# " { sleep 5 }

# --- 修改3: 使用变量化的容器IP进行文件传输 ---
expect "root@debian-armhf:~# "
# 使用 $CONTAINER_IP 变量，而不是写死的IP
send "scp root@$CONTAINER_IP:/root/squashfs-root.tar.gz /root/squashfs-root.tar.gz\r"
expect {
    "(yes/no)? " { send "yes\r"; exp_continue }
    "password: " { send "root\r" }
}

expect "root@debian-armhf:~# "
send "tar xzf squashfs-root.tar.gz && rm squashfs-root.tar.gz\r"
expect "root@debian-armhf:~# "
send "mount -o bind /dev ./squashfs-root/dev && mount -t proc /proc ./squashfs-root/proc\r"

expect "root@debian-armhf:~# "
# 同样使用 $CONTAINER_IP 变量
send "scp -r root@$CONTAINER_IP:/root/tools /root/squashfs-root/tools\r"
expect {
    "(yes/no)? " { send "yes\r"; exp_continue }
    "password: " { send "root\r" }
}

expect "root@debian-armhf:~# "
send "chroot squashfs-root/ sh\r"
expect "# "
send "chmod +x tools/patch.sh && /bin/sh tools/patch.sh\r"

# --- 修改4: 移除或修改 chroot 内部的网络配置 ---
# 此时eth0已经有了一个从DHCP获取的正确IP，无需再用静态IP创建br0，否则会覆盖正确的网络配置
# 直接启动服务即可，它会自动监听在所有IP上，包括DHCP获取到的IP
# expect "# "
# send "brctl addbr br0 && ifconfig br0 192.168.2.2/24 up\r"

expect "# "
send "/bin/httpd\r"

expect eof
EOF